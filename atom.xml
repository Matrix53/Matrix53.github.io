<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matrix53 的博客</title>
  
  <subtitle>Matrix53&#39;s Blog</subtitle>
  <link href="https://blog.matrix53.top/atom.xml" rel="self"/>
  
  <link href="https://blog.matrix53.top/"/>
  <updated>2022-02-23T07:23:54.115Z</updated>
  <id>https://blog.matrix53.top/</id>
  
  <author>
    <name>Matrix53</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Andrew Ng 机器学习笔记(持续更新)</title>
    <link href="https://blog.matrix53.top/2022/02/21/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://blog.matrix53.top/2022/02/21/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2022-02-21T11:27:56.000Z</published>
    <updated>2022-02-23T07:23:54.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>大三的寒假要结束了，突然想起来博客很久没更新了，于是特意维护了一下，更新了博客的一些配置。我还想在假期结束时写一点东西，又不太明确到底想写啥，考虑过很多，最终还是选择了机器学习。</p><p>虽然我看过一些机器学习内容，但是总感觉缺了点东西，希望能从 Andrew Ng的课程中真正入门。本篇博客将作为我机器学习课程的笔记，部分用中文较难表述的词句我将使用英文原文。</p><h2 id="第-1-周">第 1 周</h2><p>第 1周的内容比较简单，内容也非常少，分为课程介绍、单变量线性回归、线性代数复习三部分。</p><h3 id="课程介绍">课程介绍</h3><p>机器学习的定义：</p><ul><li><p><strong>非形式化定义</strong>：不显式编程，使计算机具有学习能力的研究领域</p></li><li><p><strong>形式化定义</strong>：若计算机程序在任务 T 上的性能(由 P衡量)用经验 E 来提高，则称该程序从经验 E 中学习任务 T 和性能度量P</p></li></ul><p>机器学习可以分为有监督学习和无监督学习两类：</p><ul><li><p><strong>有监督学习</strong>：已知输入和输出，求从输入到输出的映射关系。有监督学习问题分为<strong>回归</strong>和<strong>分类</strong>问题。在回归问题中，输出是连续的值，如房价预测；在分类问题中，输出是离散的值，如图像分类。</p></li><li><p><strong>无监督学习</strong>：已知输入(无标签数据集)，求输入的内在结构。无监督学习问题分为<strong>聚类</strong>和<strong>非聚类</strong>问题。给定基因数据集，将其分为多类，是聚类问题；给定高维数据集，将其降至低维，是非聚类问题。</p></li></ul><h3 id="单变量线性回归">单变量线性回归</h3><p>这一节简单讲解了有监督学习中的回归问题，以确定房价预测函数作为例子，先后完成了模型表示、确定代价函数、梯度下降寻找最优解三个步骤，笔记如下：</p><ul><li><p><strong>平方误差函数</strong>：<spanclass="math display">\[J(\theta_0,\theta_1)=\frac{1}{2m}\Sigma_{i=1}^{m}(h(x_i)-y_i)^{2}\]</span>其中，<spanclass="math inline">\(m\)</span>为样本容量，<spanclass="math inline">\(x_i,y_i\)</span>为第<spanclass="math inline">\(i\)</span>个样本的输入和输出，<spanclass="math inline">\(h\)</span>为待定函数(自变量为<spanclass="math inline">\(x\)</span>)，<spanclass="math inline">\(\theta_0,\theta_1\)</span>为<spanclass="math inline">\(h\)</span>的两个待定系数</p></li><li><p><strong>梯度下降公式</strong>：<spanclass="math display">\[\Theta:=\Theta-\alpha\frac{\partial}{\partial\Theta}J(\Theta)\]</span>其中，<spanclass="math inline">\(:=\)</span>为赋值符号，<spanclass="math inline">\(J\)</span>为代价函数，<spanclass="math inline">\(\Theta\)</span>向量为<spanclass="math inline">\(J\)</span>的参数，<spanclass="math inline">\(\Theta\)</span>向量也是待定函数<spanclass="math inline">\(h\)</span>的待定系数，<spanclass="math inline">\(\alpha\)</span>为学习率</p></li></ul><h3 id="线性代数复习">线性代数复习</h3><p>这一节的内容是线性代数基础，给出了矩阵和向量的定义，并定义了矩阵的相关运算。由于内容过于基础，就不做笔记了。如有还未学习过线性代数的读者，我推荐观看<ahref="https://www.bilibili.com/video/BV1ys411472E">3Blue1Brown的线性代数合集</a>。</p><h2 id="参考资料">参考资料</h2><ul><li>Coursera：Andrew Ng<ahref="https://www.coursera.org/learn/machine-learning">机器学习课程</a></li><li>知乎：<ahref="https://zhuanlan.zhihu.com/p/104355127">常用聚类算法</a></li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">大三的寒假即将结束，突然想起来博客很久没更新了，于是特意维护了一下，更新了一些配置。本篇博客是我机器学习课程的笔记，将会持续更新，直到我学习完机器学习课程。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.matrix53.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>uWSGI+Django自动部署</title>
    <link href="https://blog.matrix53.top/2021/08/10/uWSGI+Django%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://blog.matrix53.top/2021/08/10/uWSGI+Django%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2021-08-10T12:07:17.000Z</published>
    <updated>2022-02-19T13:15:27.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p>博客近半月没有更新，一位好友前来催更，于是有了这篇文章（bushi</p></blockquote><p>近期在学 React，本来想写几篇关于 React 的入门博客，但是 React这个框架越学越觉得博大。遂暂时放弃了写 React入门博客的想法，以免贻笑大方。本文记录了 Django框架的一种简易部署方法，使用 Nginx 反向代理 uWSGI 在一台服务器上部署Django 项目，并使用 Github Action 进行自动部署。</p><h2 id="技术栈选型">技术栈选型</h2><ul><li><a href="https://www.nginx.com/">Nginx</a>：一个 Web服务器，还能够实现反向代理，均衡负载等功能</li><li><ahref="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a>：一个 Web服务器，常用于结合 Django 等框架处理动态请求</li><li><a href="https://www.djangoproject.com/">Django</a>：一个成熟的Python 后端框架，自带多个模块</li><li><a href="https://docs.github.com/en/actions">GithubAction</a>：Github自动运行的脚本，详情见我的另一篇博客<a href="/2021/07/25/Github%E6%8E%A2%E7%A7%98/" title="Github探秘">Github探秘</a></li></ul><p>使用这个技术栈的原因：若要在一台 IP唯一的服务器上同时部署前端和后端，且均使用 HTTPS协议进行传输的话，前端和后端必定监听不同的端口。但是监听不同的端口就会产生跨域问题，而在一台服务器上解决跨域问题，一种较为简洁的方案是前端将请求反向代理给后端。而使用Nginx 将请求反向代理给 uWSGI，uWSGI处理动态请求的方案配置较少，较为简洁，于是采用这个方案。</p><p>在请求的处理上：将带有 api 前缀的请求视为动态请求（访问uWSGI），其他的请求视为静态请求（仅访问Nginx）。即，将<strong>https://ip:443/request</strong>视为静态请求，将<strong>https://ip:443/api/request</strong>视为动态请求。</p><h2 id="部署流程">部署流程</h2><p>本文不关注 Nginx、uWSGI、Django、Git等环境的安装，具体的安装步骤请到<ahref="#相关链接">相关链接</a>中查看。</p><h3 id="nginx-反向代理">Nginx 反向代理</h3><blockquote><p>关于 Nginx 的配置基础，可以参考<ahref="https://www.runoob.com/w3cnote/nginx-setup-intro.html">这个链接</a></p></blockquote><p>使用 Nginx 做反向代理，一般用到的配置参数是 proxy_pass。但是对于uWSGI，nginx 专门提供了一个更优的配置参数进行配置，即uwsgi_pass，配置文件核心内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Nginx配置文件部分内容<br># 处理动态请求<br>location /api &#123;<br>  include /etc/nginx/uwsgi_params; # Nginx提供的uWSGI配置<br>  uwsgi_pass 127.0.0.1:8000; # uWSGI监听的地址<br>&#125;<br><br># 处理静态请求<br>location / &#123;<br>  try_files $uri $uri/ /index.html;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编辑完配置文件后，需使用<code>nginx -s reload</code>命令重启nginx，配置文件才能生效。</p><h3 id="uwsgi-处理动态请求">uWSGI 处理动态请求</h3><p>uWSGI 可以手动启动，但是需要输入启动参数，这里让 uWSGI从配置文件启动。假设 Django 项目叫做 backend，uWSGI 的配置文件叫做uwsgi.ini，那么一个便于管理的项目结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Django项目结构<br>- backend<br>  - backend<br>    - __init__.py<br>    - settings.py<br>    - urls.py<br>    - asgi.py<br>    - wsgi.py<br>  - manage.py<br>  - uwsgi.ini<br></code></pre></div></td></tr></table></figure><p>配置文件 uwsgi.ini 的参考内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># uWSGI配置文件<br>[uwsgi]<br>socket=127.0.0.1:8000 # 使用nginx连接时使用<br>chdir=/path/to/backend # 项目目录<br>wsgi-file=backend/wsgi.py # 项目中wsgi.py文件的目录，相对于项目目录<br>processes=2 # 指定启动的工作进程数<br>threads=2 # 指定工作进程中的线程数<br>master=True # 指定在这些进程里有一个主进程<br>pidfile=uwsgi.pid # 保存启动之后主进程的pid<br>daemonize=uwsgi.log # 设置uwsgi后台运行，uwsgi.log保存日志信息<br>log-maxsize = 100000 # 设置日志文件最大字节数<br>max-requests = 1000 # 设置每个进程最大请求数<br></code></pre></div></td></tr></table></figure><p>在 uwsgi.ini 文件中输入配置后，就可以 cd到项目根目录下，使用<code>uwsgi --ini uwsgi.ini</code>的方式启动 uWSGI了。</p><h3 id="处理请求前缀">处理请求前缀</h3><p>若通过上述配置文件部署 Django，那么请求的前缀不会被自动去掉，即 Nginx虽然将<strong>https://ip:443/api/request</strong>这个请求传递给了Django，但是 Django 会将这个请求的 url 解析为 api/request 而不是request。</p><p>Nginx 官方推荐的解决方案是 Nginx 给 uWSGI 传递参数，uWSGI根据参数去除请求前缀，向配置文件中添加如下配置即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Nginx配置文件部分内容<br>location /api &#123;<br>  ... # 表示其他配置，实际文件中不是省略号<br>  uwsgi_param SCRIPT_NAME /api; # 表示需要去掉api前缀<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># uWSGI配置文件<br>... # 表示其他配置，实际文件中不是省略号<br>route-run = fixpathinfo: # 根据参数去除请求前缀<br></code></pre></div></td></tr></table></figure><h3 id="github-action-自动部署">Github Action 自动部署</h3><blockquote><p>若要实现向 Github 项目 push 之后就进行自动部署，可以考虑 GithubAction、Github Webhook 等方案，这里使用 Github Action。</p></blockquote><p>事实上，Django 项目的部署与更新非常简单，总体上来说需要做两件事：</p><ol type="1"><li>更新服务器上的 Python代码，考虑用<code>git pull</code>命令完成，这里需要注意服务器需要有操作项目仓库的权限</li><li>重启 uWSGI，使用<code>uwsgi --reload uwsgi.pid</code>即可</li></ol><p>注意，Nginx 是不需要重启的，因为 Nginx不需要做任何代码或者配置更新。</p><p>于是，可以这样编写<a href="https://docs.github.com/en/actions">GithubAction</a>的脚本：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">main</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">setup</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">sudo</span> <span class="hljs-string">apt</span> <span class="hljs-string">install</span> <span class="hljs-string">sshpass</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pull</span> <span class="hljs-string">and</span> <span class="hljs-string">reload</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DST:</span> <span class="hljs-string">$&#123;&#123;secrets.DST_FOLDER&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">sshpass</span> <span class="hljs-string">-p</span> <span class="hljs-string">$&#123;&#123;secrets.PASSWORD&#125;&#125;</span> <span class="hljs-string">ssh</span> <span class="hljs-string">-o</span> <span class="hljs-string">StrictHostKeyChecking=no</span> <span class="hljs-string">$&#123;&#123;secrets.USER&#125;&#125;@$&#123;&#123;secrets.IP&#125;&#125;</span> <span class="hljs-string">&quot;cd $&#123;DST&#125;; git pull; uwsgi --reload uwsgi.pid&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="结语">结语</h2><p>至此，Nginx+uWSGI 部署 Django项目的大致流程就介绍完了。读者在自己的服务器上实践可能会遇到一些坑，建议在<ahref="https://www.google.com.hk/">Google</a>或者<ahref="https://stackoverflow.com/">StackOverflow</a>上查询相关答案，或者在下方留言区写下您遇到的问题。</p><h2 id="相关链接">相关链接</h2><ul><li>Github Actions 官方文档：https://docs.github.com/en/actions</li><li>uWSGI 官方文档：https://uwsgi-docs.readthedocs.io/en/latest/</li><li>Nginx 首页：https://www.nginx.com/</li><li>Django 首页：https://www.djangoproject.com/</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">本文记录了一种使用Nginx反向代理uWSGI，进行Django项目部署的方案，使用了Github Action实现了项目的自动部署。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Github探秘</title>
    <link href="https://blog.matrix53.top/2021/07/25/Github%E6%8E%A2%E7%A7%98/"/>
    <id>https://blog.matrix53.top/2021/07/25/Github%E6%8E%A2%E7%A7%98/</id>
    <published>2021-07-25T01:48:22.000Z</published>
    <updated>2022-02-19T13:15:24.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Github作为全世界最大的代码托管网站，无数顶尖极客云集于此，更有无数极为优秀的开源代码以供学习及应用。而Github 网页端功能及其提供的 API 非常强大，配套 Git直接就能实现完整的项目管理，下面本文将向读者介绍几个 Github的进阶功能，抛砖引玉。</p><h2 id="github-actions">Github Actions</h2><p>简单地说，Github Actions是一个脚本，能够在一个指定的时机，对于某个指定的 Github仓库做一些事情。</p><ul><li><strong>指定的时机</strong>可以是在某个人对该 Github 仓库 push之后，或者是该仓库新增了一条评论之后，诸如此类时机都可以被指定为执行脚本的时机，详情见<ahref="https://docs.github.com/en/actions/reference/events-that-trigger-workflows">官方文档</a>。</li><li><strong>脚本</strong>可以非常的复杂，这里的脚本，是运行在 Github提供的一台临时服务器上的，你可以指定该服务器的系统以及系统型号，你可以在该系统上安装node.js，毕竟是服务器嘛。</li></ul><p>一个容易想到的 Github Actions 用途就是自动部署，在成员向指定仓库 push之后，可以利用临时服务器进行源代码的编译，并将要部署的文件传到自己的服务器上。从某种意义上来说，GithubActions 有点像钩子函数，只不过这个钩子函数的功能非常强大。</p><p>关于 Github Actions 入门及脚本编写，可以看这个<ahref="https://docs.github.com/en/actions">官方文档</a>。</p><figure><img src="/img/chore/github_action.png" alt="Github Actions" /><figcaption aria-hidden="true">Github Actions</figcaption></figure><h2 id="github-apps">Github Apps</h2><p>Github Apps 和 Github Actions 比较类似，你可以在 Github顶栏的<strong>Marketplace</strong>里同时找到这两项 Github提供的功能。如果要说 Apps 和 Actions的不同的话，我认为体现在<strong>集成度</strong>上面，Apps的功能更为直接和完善，开箱即用。Apps 就好像给编辑器安装的插件，而Actions 就好像给编辑器写的脚本。基于 GithubApps，你可以实现但不限于以下几件事（事实上，这只是冰山一角）：</p><ul><li>CI/CD:自动化项目构建、项目测试、项目部署等工作流</li><li>图片自动无损压缩，加快网络传输</li><li>自动关闭不活跃的 issue</li></ul><div class="note note-secondary">            <p>关于 Actions 和 Apps，读者可以在 Github 的<ahref="https://github.com/marketplace">Marketplace</a>上尽情探索。</p>          </div><figure><img src="/img/chore/github_app.png" alt="Github Apps" /><figcaption aria-hidden="true">Github Apps</figcaption></figure><h2 id="github-pages">Github Pages</h2><p>Github Pages 是一个用于网页展示的功能，于<strong>2008年</strong>推出，世界上的任何一个人，都能通过 Github展示自己的网页。可以利用 Github Pages进行个人博客托管、项目成果展示等，<ahref="https://blog.matrix53.top">我的个人博客</a>就是利用 Github Pages进行部署的，免去了购买服务器的费用。</p><p>具体来说，想要使用 Github Pages，必须建立一个名为 username.github.io的仓库（其中的 username 为用户名），然后在该仓库的设置中打开 Pages服务，这里就不赘述了。需要注意的是，不是只有该仓库才能启用 Github Pages服务，其他仓库也能启用 Pages 服务。</p><p>关于 Github Pages 的详细介绍和教程，请见<ahref="https://docs.github.com/en/pages">官方文档</a></p><h2 id="其他功能">其他功能</h2><p>Github 还有很多强大的功能，比如其提供的 REST API、GraphQLAPI、projects 和 gists 等，这里也不再叙述了。最后讲一个小故事吧，Github在 2018 年 3 月 1 日遭遇了有史以来最严重的 DDoS 攻击，峰值流量达1.35Tbps，而 Github 在 10 分钟之内化解了这次攻击。</p><h2 id="相关链接">相关链接</h2><ul><li>Github Actions 官方文档：https://docs.github.com/en/actions</li><li>Github Apps官方文档：https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps</li><li>Github Pages 官方文档：https://docs.github.com/en/pages</li><li>Github 功能总文档：https://docs.github.com/en</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">本文针对Github上的一些好用的功能进行介绍，包括但不限于Git page、Github Action等功能，帮助读者了解Github的强大之处。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客配置历程</title>
    <link href="https://blog.matrix53.top/2021/07/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%8E%86%E7%A8%8B/"/>
    <id>https://blog.matrix53.top/2021/07/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%8E%86%E7%A8%8B/</id>
    <published>2021-07-25T01:11:04.000Z</published>
    <updated>2022-02-19T13:15:20.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一直有搭建个人博客的想法，早早就买好了域名和服务器。但奈何大二下学期课业压力实在太大，一直没有足够的空闲时间搭建博客，于是大二暑假先玩了一段时间，然后着手搭建个人博客。</p><h2 id="博客框架的选择">博客框架的选择</h2><p>目前比较火的博客框架有 WordPress、Jekyll、Hexo等，下面简单罗列一下这些框架的优势劣势：</p><ul><li><strong>WordPress</strong>：经典博客框架，插件和主题非常丰富，操作简单直白，但是需要购买云服务器进行部署，访问速度受限于云服务器带宽</li><li><strong>Jekyll</strong>：Github 原生支持的博客框架，只需要把项目源码push 到 Github 仓库里，Github就能自动生成博客页面，不需要购买服务器，但是渲染速度相对于 Hexo较慢</li><li><strong>Hexo</strong>：渲染速度比 Jekyll快，可以通过静态页面的形式直接部署到 Git page上，不需要购买服务器，有中文文档</li></ul><p>最终，我选择了 Hexo 进行个人博客的搭建，将个人博客的静态文件部署到Git page 上，关于 Git page 及 Github的其他功能，详见我的另一篇文章<a href="/2021/07/25/Github%E6%8E%A2%E7%A7%98/" title="Github探秘">Github探秘</a>。</p><figure><img src="/img/chore/hexo_logo_index.png" alt="Hexo的logo" /><figcaption aria-hidden="true">Hexo的logo</figcaption></figure><h2 id="博客主题的选择">博客主题的选择</h2><p>主题方面，我是直接到了 Github 找高 Star 的主题，最终选到了 Fluid这一款主题。事实上，我友链里的博客很多也用了这一款主题，看来大家的审美差不多（x</p><p>主题挑选有两个主要途径，一个是去 Github上以<strong>hexo-theme</strong>作为关键词进行搜索，另一个是去 Hexo 的<ahref="https://hexo.io/themes/">主题商城</a>进行挑选。</p><p>关于主题和博客框架的配置，各个主题的官网以及博客框架的官网都有很详细的教程，还可以在各大搜索引擎搜索，这里就不赘述了。</p><h2 id="评论方案的选择">评论方案的选择</h2><p>评论方面，由于 Hexo 博客是无后端的静态页面，所以需要借助外部 API来配置评论功能。大体来说外部 API 分为两种，一种是基于 Github 上的 issue进行评论的方案，另一种是基于各大 BaaS 供应商提供的服务。我选择的是基于Github issue 的 utterances 评论方案，该方案的特点是免费开源、使用 Github账号进行评论、文章和 Github issue 绑定、可直接访问评论者的 Github主页。</p><ul><li>基于 Github 上的 issue 的方案：<ahref="https://github.com/utterance/utterances">utterances</a>、<ahref="https://github.com/gitalk/gitalk">gitalk</a>等</li><li>基于 BaaS 供应商的方案：<ahref="https://valine.js.org/">valine</a>、<ahref="https://waline.js.org/">waline</a>、<ahref="https://disqus.com/">disqus</a>等</li></ul><p>另外，如果使用的是 Fluid 主题，那么 Fluid主题的官网和配置文件里有很详细的评论配置方案。</p><h2 id="公式渲染器的选择">公式渲染器的选择</h2><p>原生的 Hexo 框架不支持渲染 Latex，但是可以通过安装插件的方法支持Latex 语法。相关插件包括但不限于以下几个，我安装的插件是markdown-it-plus。</p><ul><li><ahref="https://github.com/hexojs/hexo-math">hexo-math</a>：同时支持 Katex和 Mathjax，是 Hexo 的官方数学公式插件</li><li><ahref="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus</a>：支持Katex，Fluid 主题推荐方案之一</li><li><ahref="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>：支持Mathjax，Fluid 主题推荐方案之一</li></ul><p>另外，Latex 是一套排版语言，而 Katex 和 Mathjax 是渲染 Latex的引擎。Katex 更为轻量，而 Mathjax 能渲染更复杂的数学符号，日常使用来说Katex 就够用了。</p><h2 id="相关链接">相关链接</h2><p>下面是我搭建博客时查阅的一些链接，以供读者参考：</p><ul><li>Hexo 框架官网：https://hexo.io</li><li>Fluid 主题官网：https://hexo.fluid-dev.com/docs</li><li>utterances评论方案仓库：https://github.com/utterance/utterances</li><li>markdown-it-plus渲染器仓库：https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">一直有搭建个人博客的想法，早早就买好了域名和服务器。但奈何大二下学期课业压力实在太大，一直没有足够的空闲时间搭建博客，于是大二暑假先玩了一段时间，然后着手搭建个人博客。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>

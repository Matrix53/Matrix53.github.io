<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matrix53 的博客</title>
  
  <subtitle>Matrix53&#39;s Blog</subtitle>
  <link href="https://blog.matrix53.top/atom.xml" rel="self"/>
  
  <link href="https://blog.matrix53.top/"/>
  <updated>2022-05-13T06:59:08.872Z</updated>
  <id>https://blog.matrix53.top/</id>
  
  <author>
    <name>Matrix53</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Andrew Ng 机器学习笔记(第3周)</title>
    <link href="https://blog.matrix53.top/2022/05/10/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E5%91%A8/"/>
    <id>https://blog.matrix53.top/2022/05/10/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E5%91%A8/</id>
    <published>2022-05-10T07:36:48.000Z</published>
    <updated>2022-05-13T06:59:08.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个系列的博客将作为我机器学习课程的笔记，部分用中文较难表述的词句我将使用英文原文。</p><p>第 3周的课程标题是分类问题，包括分类问题及其表示、逻辑回归模型、多类分类问题、解决过拟合四部分。</p><h2 id="分类问题及其表示">分类问题及其表示</h2><p><strong>Sigmoid 函数</strong>(Logistic 函数)：将<spanclass="math inline">\([-\infty, \infty]\)</span>映射到<spanclass="math inline">\([0,1]\)</span>，可用于将数值转化为概率，其函数表达式如下。</p><p><span class="math display">\[g(z)=\frac{1}{1+e^{-z}}\]</span></p><p><strong>决策边界</strong>(<ahref="https://en.wikipedia.org/wiki/Decision_boundary">DecisionBoundary</a>)：在二分类问题中，决策边界是一个将向量空间一分为二的超平面，在决策边界两侧的点属于不同的类别。</p><h2 id="逻辑回归模型">逻辑回归模型</h2><p>待优化的<span class="math inline">\(J(\Theta)\)</span>是由<spanclass="math inline">\(Cost(h_{\theta}(x),y)\)</span>和<spanclass="math inline">\(h_{\theta}(x)\)</span>共同决定的，当<spanclass="math inline">\(J(\Theta)\)</span>是<ahref="https://en.wikipedia.org/wiki/Convex_function">凸函数</a>时，可以找到<strong>全局最优解</strong>。</p><p>在<strong>逻辑回归</strong>(LogisticRegression)模型中，有如下公式：</p><p><span class="math inline">\(h_{\theta}(x)=g(\Theta^T x)\)</span></p><p><spanclass="math inline">\(Cost(h_{\theta}(x),y)=-y\log(h_{\theta}(x))-\left(1-y\right)\log(1-h_{\theta}(x))\)</span></p><p><spanclass="math inline">\(\theta_j=\theta_j-\frac{\alpha}{m}\Sigma_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}\)</span></p><p>除了梯度下降算法<strong>之外</strong>，还有很多算法能够优化<spanclass="math inline">\(\Theta\)</span>，例如 <ahref="https://en.wikipedia.org/wiki/Conjugate_gradient_method">ConjugateGradient</a>、<ahref="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">BFGS</a>、<ahref="https://en.wikipedia.org/wiki/Limited-memory_BFGS">L-BFGS</a>等，建议使用<strong>库函数</strong>而不是手写这些算法。</p><h2 id="多类分类问题">多类分类问题</h2><p><strong>One-vs-all</strong>：对于有<spanclass="math inline">\(n\)</span>个类的分类问题，可以训练<spanclass="math inline">\(n\)</span>个逻辑回归分类器，第<spanclass="math inline">\(i\)</span>个分类器预测<spanclass="math inline">\(y=i\)</span>的概率，最后选择这些概率中<strong>最大值所在的类</strong>作为预测结果。</p><h2 id="解决过拟合">解决过拟合</h2><p><strong>欠拟合</strong>(<ahref="https://en.wikipedia.org/wiki/Overfitting#Underfitting">underfitting</a>、highbias)：算法在训练集上表现不好，没有学习到数据的内在结构。</p><p><strong>过拟合</strong>(<ahref="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>、highvariance)：算法在训练集上表现好，但在测试集上表现不好，泛化性能差。</p><p>可以通过<strong>减少特征的数量</strong>或者<strong>正则化</strong>等方法，来解决过拟合问题。</p><p><strong>正则化</strong>(<ahref="https://en.wikipedia.org/wiki/Regularization_(mathematics)">Regularization</a>)：将最终拟合出的函数“简单化”的方法，分为显式正则化和隐式正则化。</p><h2 id="参考资料">参考资料</h2><ul><li>Coursera：Andrew Ng<ahref="https://www.coursera.org/learn/machine-learning">机器学习课程</a></li><li>知乎：<ahref="https://zhuanlan.zhihu.com/p/104355127">常用聚类算法</a></li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">机器学习课程第3周的笔记，本周的内容包括分类问题及其表示、逻辑回归模型、多类分类问题、解决过拟合四部分。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.matrix53.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Andrew Ng 机器学习笔记(第2周)</title>
    <link href="https://blog.matrix53.top/2022/04/18/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E5%91%A8/"/>
    <id>https://blog.matrix53.top/2022/04/18/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E5%91%A8/</id>
    <published>2022-04-18T13:54:52.000Z</published>
    <updated>2022-05-13T06:59:12.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个系列的博客将作为我机器学习课程的笔记，部分用中文较难表述的词句我将使用英文原文。</p><p>第 2周的课程标题是多变量梯度下降，包括多变量线性回归、解析法计算参数、Octave语法入门三部分。</p><h2 id="多变量线性回归">多变量线性回归</h2><p>多变量线性回归的一些<strong>公式</strong>：</p><ul><li><p><strong>待定函数</strong>为：<spanclass="math display">\[H(X)=\Theta^{T}X\]</span>其中，<spanclass="math inline">\(\Theta\)</span>向量为待定系数，<spanclass="math inline">\(X\)</span>向量为自变量</p></li><li><p><strong>梯度下降公式</strong>仍为：<spanclass="math display">\[\Theta:=\Theta-\alpha\frac{\partial}{\partial\Theta}J(\Theta)\]</span>其中，<spanclass="math inline">\(:=\)</span>为赋值符号，<spanclass="math inline">\(J\)</span>为代价函数，<spanclass="math inline">\(\Theta\)</span>向量为<spanclass="math inline">\(J\)</span>的参数，<spanclass="math inline">\(\Theta\)</span>向量也是待定函数<spanclass="math inline">\(H\)</span>的待定系数，<spanclass="math inline">\(\alpha\)</span>为学习率</p></li></ul><p>多变量线性回归的一些 <strong>Trick</strong>：</p><ul><li><p>对于一些数据范围较大的特征，可以采用<strong>特征缩放</strong>将其归一化，加速梯度下降的收敛</p></li><li><p>学习率过大可能导致梯度下降不收敛，学习率过小则梯度下降收敛较慢</p></li><li><p>当线性回归拟合数据效果不好时，可以采用多项式回归</p></li></ul><h2 id="解析法计算参数">解析法计算参数</h2><p>对于多变量线性回归，可以解析地计算出最优的<spanclass="math inline">\(\Theta\)</span>向量，公式为：<spanclass="math display">\[\Theta=(X^{T}X)^{-1}X^{T}y\]</span>其中，<spanclass="math inline">\(X\)</span>矩阵是<span class="math inline">\(m\times (n+1)\)</span>的矩阵，每一行代表一个样本数据。<spanclass="math inline">\(X\)</span>矩阵第 <spanclass="math inline">\(1\)</span> 列的元素均为 <spanclass="math inline">\(1\)</span>，第<spanclass="math inline">\((n+1)\)</span>列表示第<spanclass="math inline">\(n\)</span>个特征。<spanclass="math inline">\(y\)</span>向量是列向量，<spanclass="math inline">\(y\)</span>向量的第<spanclass="math inline">\(n\)</span>个元素表示第<spanclass="math inline">\(n\)</span>个样本对应的真实输出。</p><p>多变量线性回归问题，梯度下降法的时间复杂度是<spanclass="math inline">\(O(kn^{2})\)</span>(<spanclass="math inline">\(k\)</span>为迭代次数)，而解析法计算的时间复杂度是<spanclass="math inline">\(O(n^3)\)</span>。</p><p>若使用解析法计算参数时，发现矩阵<spanclass="math inline">\(X^TX\)</span>不可逆，则可能发生了以下情况：</p><ol type="1"><li><p>特征重复，可能存在两个线性相关的特征，可以考虑消除这种线性相关性</p></li><li><p>特征太多了(<span class="math inline">\(m \len\)</span>)，可以考虑删除一些特征</p></li></ol><h2 id="octavematlab-入门">Octave/Matlab 入门</h2><h3 id="octavematlab-的基础操作">Octave/Matlab 的基础操作</h3><ul><li><p>算术运算：<code>+(加)</code>, <code>-(减)</code>,<code>*(乘)</code>, <code>/(除)</code>, <code>^(幂)</code></p></li><li><p>数值比较：<code>==(等于)</code>, <code>~=(不等于)</code>,<code>&gt;(大于)</code>, <code>&lt;(小于)</code>,<code>&gt;=(大于等于)</code>, <code>&lt;=(小于等于)</code></p></li><li><p>逻辑运算：<code>&amp;&amp;(逻辑与)</code>,<code>||(逻辑或)</code>, <code>xor(逻辑异或)</code></p></li><li><p>一段代码示例：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">a = <span class="hljs-built_in">pi</span>; <span class="hljs-comment">% 这是注释</span><br>b = <span class="hljs-string">&#x27;hi&#x27;</span>; <span class="hljs-comment">% 在语句后加;可以阻止REPL输出</span><br>a <span class="hljs-comment">% 输出a，也可使用disp(a)</span><br><span class="hljs-built_in">disp</span>(sprintf(<span class="hljs-string">&#x27;2 decimals: %0.2f&#x27;</span>, a)) <span class="hljs-comment">% 输出2位小数</span><br>format long <span class="hljs-comment">% 设置REPL输出更长的数据</span><br></code></pre></div></td></tr></table></figure></li><li><p>矩阵和向量的表示：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>;<span class="hljs-number">3</span> <span class="hljs-number">4</span>;<span class="hljs-number">5</span> <span class="hljs-number">6</span>] <span class="hljs-comment">% 定义一个3行2列的矩阵</span><br>v = [<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>] <span class="hljs-comment">% 定义一个列向量</span><br>v = <span class="hljs-number">1</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">2</span> <span class="hljs-comment">% 定义一个行向量，行向量的元素为1, 1.1, 1.2, ..., 2</span><br>v = <span class="hljs-number">1</span>:<span class="hljs-number">6</span> <span class="hljs-comment">% 定义一个行向量，行向量的元素为1, 2, 3, ..., 6</span><br>C = <span class="hljs-number">2</span>*<span class="hljs-built_in">ones</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">% 定义一个2行3列的全2矩阵</span><br>w = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">% 定义一个1行3列的全0矩阵</span><br>w = <span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">% 定义一个1行3列的矩阵，元素均为0到1之间的随机数</span><br>w = <span class="hljs-number">-6</span> + <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)*(<span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>))<br>hist(w,<span class="hljs-number">50</span>) <span class="hljs-comment">% 绘制w的直方图，50为直方图的组数</span><br>I = <span class="hljs-built_in">eye</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">% 定义一个4阶单位矩阵</span><br></code></pre></div></td></tr></table></figure></li><li><p>帮助命令：<code>help</code></p></li></ul><h3 id="octavematlab-的数据处理">Octave/Matlab 的数据处理</h3><ul><li><p>查看矩阵/向量的维数：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>; <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br><span class="hljs-built_in">size</span>(A) <span class="hljs-comment">% 输出矩阵A的大小，结果为[3 2]</span><br><span class="hljs-built_in">size</span>(A,<span class="hljs-number">1</span>) <span class="hljs-comment">% 输出矩阵A第一维的大小，结果为3</span><br>v = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br><span class="hljs-built_in">length</span>(v) <span class="hljs-comment">% 输出向量v的长度，结果为4</span><br><span class="hljs-built_in">length</span>(A) <span class="hljs-comment">% 输出矩阵A第一维的大小，结果为3</span><br></code></pre></div></td></tr></table></figure></li><li><p>工作目录操作：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">pwd <span class="hljs-comment">% 输出当前目录</span><br>cd <span class="hljs-string">&#x27;C:\Users\Administrator\Desktop&#x27;</span> <span class="hljs-comment">% 切换到桌面</span><br>ls <span class="hljs-comment">% 显示当前目录下的文件</span><br>mkdir <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-comment">% 在当前目录下创建一个文件夹</span><br>rmdir <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-comment">% 删除当前目录下的文件夹</span><br></code></pre></div></td></tr></table></figure></li></ul><div class="note note-secondary">            <p>.dat后缀的文件一般为数据文件，该后缀被多种软件所使用，每个软件定义的数据内容很可能不一样。下文中，.dat文件的内容为以空格分隔的数字，每行代表一个样本，每列代表一个特征。</p>          </div><ul><li><p>数据载入相关操作：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A = load(<span class="hljs-string">&#x27;data.dat&#x27;</span>) <span class="hljs-comment">% 从data.dat文件中载入数据，结果为一个矩阵</span><br>who <span class="hljs-comment">% 输出当前会话的所有变量名</span><br>whos <span class="hljs-comment">% 输出当前会话的所有变量的详细信息</span><br>clear A <span class="hljs-comment">% 删除变量A</span><br>v = A(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>,<span class="hljs-number">1</span>:<span class="hljs-number">2</span>) <span class="hljs-comment">% 取出矩阵A的第1行到第10行，第1列到第2列的元素</span><br>save hello.mat v <span class="hljs-comment">% 保存变量v到hello.mat文件中，该文件为二进制文件</span><br>clear <span class="hljs-comment">% 删除所有变量</span><br>save hello.txt v -ascii <span class="hljs-comment">% 保存变量v到hello.txt文件中，-ascii表示以ASCII码保存</span><br></code></pre></div></td></tr></table></figure></li><li><p>矩阵/向量切片操作</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 输出矩阵A的第3行第2列的元素</span><br>A(<span class="hljs-number">2</span>,:) <span class="hljs-comment">% 输出矩阵A的第2行的所有元素</span><br>A([<span class="hljs-number">1</span> <span class="hljs-number">3</span>],:) <span class="hljs-comment">% 输出矩阵A的第1行和第3行的所有元素</span><br>A(:,<span class="hljs-number">2</span>) = [<span class="hljs-number">10</span>; <span class="hljs-number">11</span>; <span class="hljs-number">12</span>] <span class="hljs-comment">% 将矩阵A的第2列赋值为10, 11, 12</span><br>A = [A, [<span class="hljs-number">100</span>; <span class="hljs-number">101</span>; <span class="hljs-number">102</span>]] <span class="hljs-comment">% 将列向量[100; 101; 102]添加到矩阵A的最后一列</span><br>A(:) <span class="hljs-comment">% 将矩阵A转换为列向量</span><br>A = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>B = [<span class="hljs-number">5</span> <span class="hljs-number">6</span>; <span class="hljs-number">7</span> <span class="hljs-number">8</span>]<br>C = [A B] <span class="hljs-comment">% 将矩阵A和B按行拼接，结果为[1 2 5 6; 3 4 7 8]，等价于[A, B]</span><br>C = [A; B] <span class="hljs-comment">% 将矩阵A和B按列拼接，结果为[1 2; 3 4; 5 6; 7 8]</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="octavematlab-的矩阵运算">Octave/Matlab 的矩阵运算</h3><ul><li><p>矩阵/向量的基本运算(一)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>; <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br>B = [<span class="hljs-number">11</span> <span class="hljs-number">12</span>; <span class="hljs-number">13</span> <span class="hljs-number">14</span>; <span class="hljs-number">15</span> <span class="hljs-number">16</span>]<br>C = [<span class="hljs-number">1</span> <span class="hljs-number">1</span>; <span class="hljs-number">2</span> <span class="hljs-number">2</span>]<br>A * C <span class="hljs-comment">% 矩阵A和矩阵C的乘积，结果为[5 5; 11 11; 17 17]</span><br>A .* B <span class="hljs-comment">% 矩阵A和矩阵B对应位置的元素相乘，结果为[11 24; 39 56; 75 96]</span><br>A .^ <span class="hljs-number">2</span> <span class="hljs-comment">% 矩阵A每个位置的元素取平方，结果为[1 4; 9 16; 25 36]</span><br>v = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>]<br><span class="hljs-number">1</span> ./ v <span class="hljs-comment">% 向量v每个位置的元素取倒数，结果为[1.0000; 0.5000; 0.3333]</span><br><span class="hljs-built_in">log</span>(v) <span class="hljs-comment">% 向量v每个位置的元素取自然对数，结果为[0.0000; 0.6931; 1.0986]</span><br><span class="hljs-built_in">exp</span>(v) <span class="hljs-comment">% 向量v每个位置的元素取指数(以e为底数)，结果为[2.7183; 7.3891; 20.0855]</span><br><span class="hljs-built_in">abs</span>(v) <span class="hljs-comment">% 向量v每个位置的元素取绝对值，结果为[1.0000; 2.0000; 3.0000]</span><br>-v <span class="hljs-comment">% 向量v每个位置的元素取负，结果为[-1.0000; -2.0000; -3.0000]</span><br>v + <span class="hljs-number">1</span> <span class="hljs-comment">% 向量v每个位置的元素加1，结果为[2.0000; 3.0000; 4.0000]</span><br></code></pre></div></td></tr></table></figure></li><li><p>矩阵/向量的基本运算(二)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">A&#x27; <span class="hljs-comment">% 矩阵A的转置，结果为[1 3 5; 2 4 6]</span><br>a = [<span class="hljs-number">1</span> <span class="hljs-number">15</span> <span class="hljs-number">2</span> <span class="hljs-number">0.5</span>]<br>val = <span class="hljs-built_in">max</span>(a) <span class="hljs-comment">% 向量a中的最大值，结果为15</span><br>[val, ind] = <span class="hljs-built_in">max</span>(a) <span class="hljs-comment">% 向量a中的最大值和最大值的索引，结果为[15, 2]</span><br><span class="hljs-built_in">max</span>(A) <span class="hljs-comment">% 矩阵A每一列的最大值，结果为[5 6]</span><br>a &lt; <span class="hljs-number">3</span> <span class="hljs-comment">% 向量a中的每个元素是否小于3，结果为[1 0 1 1]</span><br><span class="hljs-built_in">find</span>(a &lt; <span class="hljs-number">3</span>) <span class="hljs-comment">% 找出向量a中每个小于3的元素的索引，结果为[1 3 4]</span><br>A = <span class="hljs-built_in">magic</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">% 生成一个3阶幻方，结果为[8 1 6; 3 5 7; 4 9 2]</span><br>[r,c] = <span class="hljs-built_in">find</span>(A &gt;= <span class="hljs-number">7</span>) <span class="hljs-comment">% 找到矩阵A中每个大于等于7的元素的行和列索引，r(行索引)为[1 3 2]，c(列索引)为[1 2 3]</span><br>sum(a) <span class="hljs-comment">% 向量a中的元素求和，结果为18.5</span><br>prod(a) <span class="hljs-comment">% 向量a中的元素求乘积，结果为15</span><br><span class="hljs-built_in">floor</span>(a) <span class="hljs-comment">% 向量a中的元素向下取整，结果为[1 15 2 0]</span><br><span class="hljs-built_in">ceil</span>(a) <span class="hljs-comment">% 向量a中的元素向上取整，结果为[1 15 2 1]</span><br></code></pre></div></td></tr></table></figure></li><li><p>矩阵/向量的基本运算(三)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">rand</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">% 生成一个三阶方阵，方阵中的每一个元素为0到1之间的随机数</span><br><span class="hljs-built_in">max</span>(<span class="hljs-built_in">rand</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">rand</span>(<span class="hljs-number">3</span>)) <span class="hljs-comment">% 生成两个三阶方阵，并对对应位置的元素求最大值</span><br><span class="hljs-built_in">max</span>(A,[],<span class="hljs-number">1</span>) <span class="hljs-comment">% 矩阵A每一列的最大值，结果为[8 9 7]</span><br><span class="hljs-built_in">max</span>(A,[],<span class="hljs-number">2</span>) <span class="hljs-comment">% 矩阵A每一行的最大值，结果为[8; 7; 9]</span><br><span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(A)) <span class="hljs-comment">% 矩阵A中的最大值，结果为9</span><br>A = <span class="hljs-built_in">magic</span>(<span class="hljs-number">9</span>)<br>sum(A,<span class="hljs-number">1</span>) <span class="hljs-comment">% 矩阵A每一列的元素求和，结果为[369 369 369 369 369 369 369 369 369]</span><br><span class="hljs-built_in">flipud</span>(A) <span class="hljs-comment">% 以水平方向为轴翻转矩阵A</span><br>pinv(A) <span class="hljs-comment">% 矩阵A的逆，pinv(A)*A的结果近似等于eye(9)</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="octavematlab-的绘图">Octave/Matlab 的绘图</h3><ul><li><p>Matlab/Octave 绘图(一)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">t=[<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">0.98</span>]<br>y1=<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*<span class="hljs-number">4</span>*t)<br><span class="hljs-built_in">plot</span>(t,y1) <span class="hljs-comment">% 绘制y1的曲线，颜色默认为蓝色</span><br><span class="hljs-built_in">hold</span> on <span class="hljs-comment">% 在当前绘图区域继续绘图，不清除当前绘图区域</span><br>y2=<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*<span class="hljs-number">4</span>*t)<br><span class="hljs-built_in">plot</span>(t,y2,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment">% 绘制红色的曲线</span><br>xlabel(<span class="hljs-string">&#x27;time&#x27;</span>) <span class="hljs-comment">% 设置x轴的标签</span><br>ylabel(<span class="hljs-string">&#x27;value&#x27;</span>) <span class="hljs-comment">% 设置y轴的标签</span><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;sin&#x27;</span>,<span class="hljs-string">&#x27;cos&#x27;</span>) <span class="hljs-comment">% 设置图例，legend(&#x27;sin&#x27;,&#x27;cos&#x27;)表示在图例中显示两条曲线的名称</span><br>title(<span class="hljs-string">&#x27;my plot&#x27;</span>) <span class="hljs-comment">% 设置标题</span><br>cd <span class="hljs-string">&#x27;C:\Users\Matrix53\Desktop&#x27;</span> <span class="hljs-comment">% 切换到桌面</span><br>print -dpng <span class="hljs-string">&#x27;myPlot.png&#x27;</span> <span class="hljs-comment">% 保存当前绘图区域为一个png文件</span><br>close <span class="hljs-comment">% 关闭当前绘图区域</span><br></code></pre></div></td></tr></table></figure><p>绘制结果如下：<img src="/img/AI/plot_1.png" alt="绘制两条曲线" width="50%"/></p></li><li><p>Matlab/Octave 绘图(二)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">% 切换到第一个绘图区域</span><br><span class="hljs-built_in">plot</span>(t,y1) <span class="hljs-comment">% 在第一个绘图区域绘制y1</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">% 切换到第二个绘图区域</span><br><span class="hljs-built_in">plot</span>(t,y2) <span class="hljs-comment">% 在第二个绘图区域绘制y2</span><br></code></pre></div></td></tr></table></figure><p>绘制结果如下：<img src="/img/AI/plot_2.png" alt="第一个绘图窗口" width="50%"/><img src="/img/AI/plot_3.png" alt="第二个绘图窗口" width="50%"/></p></li><li><p>Matlab/Octave 绘图(三)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">% 将绘图区域分为 1×2 的矩阵，准备在第一个区域画图</span><br><span class="hljs-built_in">plot</span>(t,y1) <span class="hljs-comment">% 在第一个绘图区域绘制y1</span><br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">% 将绘图区域分为 1×2 的矩阵，准备在第二个区域画图</span><br><span class="hljs-built_in">plot</span>(t,y2) <span class="hljs-comment">% 在第二个绘图区域绘制y2</span><br></code></pre></div></td></tr></table></figure><p>绘制结果如下： <img src="/img/AI/plot_4.png"alt="绘图窗口的切分" /></p></li><li><p>Matlab/Octave 绘图(四)：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab">axis([<span class="hljs-number">0.5</span> <span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">1</span>]) <span class="hljs-comment">% 将横轴的范围设置为[0.5,1]，将纵轴的范围设置为[-1,1]</span><br>clf <span class="hljs-comment">% 清空当前绘图区域</span><br>A = <span class="hljs-built_in">magic</span>(<span class="hljs-number">5</span>)<br>imagesc(A) <span class="hljs-comment">% 绘制矩阵A的热力图</span><br>colorbar <span class="hljs-comment">% 显示每个颜色与值的对应关系</span><br>colormap(gray) <span class="hljs-comment">% 将热力图显示为灰度图，这三条指令也可写为`imagesc(A), colorbar, colormap gray`一行</span><br></code></pre></div></td></tr></table></figure><p>绘制结果如下：<img src="/img/AI/plot_5.png" alt="灰度图的显示" width="50%"/></p></li></ul><h3 id="octavematlab-的流程控制">Octave/Matlab 的流程控制</h3><ul><li><p>Matlab/Octave 的循环语句：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">% 初始化 10×1 的零向量</span><br>v = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">% for 循环的基础语法</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">10</span>,<br>  v(<span class="hljs-built_in">i</span>)=<span class="hljs-number">2</span>^<span class="hljs-built_in">i</span>;<br><span class="hljs-keyword">end</span>;<br><span class="hljs-comment">% while 循环的基础语法</span><br><span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">i</span>&lt;= <span class="hljs-number">5</span>,<br>  v(<span class="hljs-built_in">i</span>) = <span class="hljs-number">100</span>;<br>  <span class="hljs-built_in">i</span> = <span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">end</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>Matlab/Octave 的分支语句：</p><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">% 初始化 a</span><br>a = <span class="hljs-number">3</span>;<br><span class="hljs-comment">% if 语句的基础语法</span><br><span class="hljs-keyword">if</span> a==<span class="hljs-number">3</span>,<br>  <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;a is 3&#x27;</span>) <span class="hljs-comment">% 末尾可以加;</span><br><span class="hljs-keyword">elseif</span> a==<span class="hljs-number">4</span>,<br>  <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;a is 4&#x27;</span>)<br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;a is not 3 or 4&#x27;</span>)<br><span class="hljs-keyword">end</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>Matlab/Octave 的函数定义：</p><div class="note note-secondary">            <p>Matlab/Octave一般将函数定义在单独的文件中，暴露出的函数名必须与文件名一致。</p><p>Matlab/Octave 的 REPL 存在搜索路径的概念，REPL可以使用搜索路径下<code>.m</code>文件中的函数，搜索路径包括<code>pwd</code>。</p><p>另外，还可使用匿名函数、inline命令等来定义函数，下文的函数定义均在<code>.m</code>文件中进行。</p>          </div><figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">% squareThisNumber.m</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[y]</span> = <span class="hljs-title">squareThisNumber</span><span class="hljs-params">(x)</span></span><br>  y = x^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% REPL</span><br>addpath(<span class="hljs-string">&#x27;path/to/squareThisNumber.m&#x27;</span>) <span class="hljs-comment">% 将函数添加到搜索路径</span><br>squareThisNumber(<span class="hljs-number">3</span>) <span class="hljs-comment">% 调用函数，结果为9</span><br><span class="hljs-comment">% squareAndCubeThisNumber.m</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[y1,y2]</span> = <span class="hljs-title">squareAndCubeThisNumber</span><span class="hljs-params">(x)</span></span><br>  y1 = x^<span class="hljs-number">2</span>;<br>  y2 = x^<span class="hljs-number">3</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% REPL</span><br>addpath(<span class="hljs-string">&#x27;path/to/squareAndCubeThisNumber.m&#x27;</span>) <span class="hljs-comment">% 将函数添加到搜索路径</span><br>[a,b] = squareAndCubeThisNumber(<span class="hljs-number">3</span>) <span class="hljs-comment">% 调用函数，a=9,b=27</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="tips-将计算向量化">Tips: 将计算向量化</h3><ul><li>Matlab、Octave、Python等语言都有内置的或者第三方的高性能计算库，这些库对矩阵运算做了特别的优化，在实现模型时使用矩阵进行运算往往能提高效率。</li></ul><h2 id="参考资料">参考资料</h2><ul><li>Coursera：Andrew Ng<ahref="https://www.coursera.org/learn/machine-learning">机器学习课程</a></li><li>知乎：<ahref="https://zhuanlan.zhihu.com/p/104355127">常用聚类算法</a></li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">机器学习课程第2周的笔记，本周的内容包括多变量线性回归、解析法计算参数、Octave 语法入门三部分。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.matrix53.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Andrew Ng 机器学习笔记(第1周)</title>
    <link href="https://blog.matrix53.top/2022/04/18/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E5%91%A8/"/>
    <id>https://blog.matrix53.top/2022/04/18/Andrew-Ng-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E5%91%A8/</id>
    <published>2022-04-18T13:54:32.000Z</published>
    <updated>2022-05-13T06:59:14.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这个系列的博客将作为我机器学习课程的笔记，部分用中文较难表述的词句我将使用英文原文。</p><p>第 1周的内容比较简单，内容也非常少，分为课程介绍、单变量线性回归、线性代数复习三部分。</p><h2 id="课程介绍">课程介绍</h2><p>机器学习的定义：</p><ul><li><p><strong>非形式化定义</strong>：不显式编程，使计算机具有学习能力的研究领域</p></li><li><p><strong>形式化定义</strong>：若计算机程序在任务 T 上的性能(由 P衡量)用经验 E 来提高，则称该程序从经验 E 中学习任务 T 和性能度量P</p></li></ul><p>机器学习可以分为有监督学习和无监督学习两类：</p><ul><li><p><strong>有监督学习</strong>：已知输入和输出，求从输入到输出的映射关系。有监督学习问题分为<strong>回归</strong>和<strong>分类</strong>问题。在回归问题中，输出是连续的值，如房价预测；在分类问题中，输出是离散的值，如图像分类。</p></li><li><p><strong>无监督学习</strong>：已知输入(无标签数据集)，求输入的内在结构。无监督学习问题分为<strong>聚类</strong>和<strong>非聚类</strong>问题。给定基因数据集，将其分为多类，是聚类问题；给定高维数据集，将其降至低维，是非聚类问题。</p></li></ul><h2 id="单变量线性回归">单变量线性回归</h2><p>这一节简单讲解了有监督学习中的回归问题，以确定房价预测函数作为例子，先后完成了模型表示、确定代价函数、梯度下降寻找最优解三个步骤，笔记如下：</p><ul><li><p><strong>平方误差函数</strong>：<spanclass="math display">\[J(\theta_0,\theta_1)=\frac{1}{2m}\Sigma_{i=1}^{m}(h(x_i)-y_i)^{2}\]</span>其中，<spanclass="math inline">\(m\)</span>为样本容量，<spanclass="math inline">\(x_i,y_i\)</span>为第<spanclass="math inline">\(i\)</span>个样本的输入和输出，<spanclass="math inline">\(h\)</span>为待定函数(自变量为<spanclass="math inline">\(x\)</span>)，<spanclass="math inline">\(\theta_0,\theta_1\)</span>为<spanclass="math inline">\(h\)</span>的两个待定系数</p></li><li><p><strong>梯度下降公式</strong>：<spanclass="math display">\[\Theta:=\Theta-\alpha\frac{\partial}{\partial\Theta}J(\Theta)\]</span>其中，<spanclass="math inline">\(:=\)</span>为赋值符号，<spanclass="math inline">\(J\)</span>为代价函数，<spanclass="math inline">\(\Theta\)</span>向量为<spanclass="math inline">\(J\)</span>的参数，<spanclass="math inline">\(\Theta\)</span>向量也是待定函数<spanclass="math inline">\(h\)</span>的待定系数，<spanclass="math inline">\(\alpha\)</span>为学习率</p></li></ul><h2 id="线性代数复习">线性代数复习</h2><p>这一节的内容是线性代数基础，给出了矩阵和向量的定义，并定义了矩阵的相关运算。由于内容过于基础，就不做笔记了。如有还未学习过线性代数的读者，我推荐观看<ahref="https://www.bilibili.com/video/BV1ys411472E">3Blue1Brown的线性代数合集</a>。</p><h2 id="参考资料">参考资料</h2><ul><li>Coursera：Andrew Ng<ahref="https://www.coursera.org/learn/machine-learning">机器学习课程</a></li><li>知乎：<ahref="https://zhuanlan.zhihu.com/p/104355127">常用聚类算法</a></li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">机器学习课程第1周的笔记，本周的内容包括课程介绍、单变量线性回归、线性代数复习三部分。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.matrix53.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>uWSGI+Django自动部署</title>
    <link href="https://blog.matrix53.top/2021/08/10/uWSGI+Django%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://blog.matrix53.top/2021/08/10/uWSGI+Django%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2021-08-10T12:07:17.000Z</published>
    <updated>2022-05-13T06:57:56.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p>博客近半月没有更新，一位好友前来催更，于是有了这篇文章（bushi</p></blockquote><p>近期在学 React，本来想写几篇关于 React 的入门博客，但是 React这个框架越学越觉得博大。遂暂时放弃了写 React入门博客的想法，以免贻笑大方。本文记录了 Django框架的一种简易部署方法，使用 Nginx 反向代理 uWSGI 在一台服务器上部署Django 项目，并使用 Github Action 进行自动部署。</p><h2 id="技术栈选型">技术栈选型</h2><ul><li><a href="https://www.nginx.com/">Nginx</a>：一个 Web服务器，还能够实现反向代理，均衡负载等功能</li><li><ahref="https://uwsgi-docs.readthedocs.io/en/latest/">uWSGI</a>：一个 Web服务器，常用于结合 Django 等框架处理动态请求</li><li><a href="https://www.djangoproject.com/">Django</a>：一个成熟的Python 后端框架，自带多个模块</li><li><a href="https://docs.github.com/en/actions">GithubAction</a>：Github自动运行的脚本，详情见我的另一篇博客<a href="/2021/07/25/Github%E6%8E%A2%E7%A7%98/" title="Github探秘">Github探秘</a></li></ul><p>使用这个技术栈的原因：若要在一台 IP唯一的服务器上同时部署前端和后端，且均使用 HTTPS协议进行传输的话，前端和后端必定监听不同的端口。但是监听不同的端口就会产生跨域问题，而在一台服务器上解决跨域问题，一种方案是前端将请求反向代理给后端。而使用Nginx 将请求反向代理给 uWSGI，uWSGI处理动态请求的方案配置较少，较为简洁，于是采用这个方案。</p><p>在请求的处理上：将带有 api 前缀的请求视为动态请求（访问uWSGI），其他的请求视为静态请求（仅访问Nginx）。即，将<strong>https://ip:443/request</strong>视为静态请求，将<strong>https://ip:443/api/request</strong>视为动态请求。</p><h2 id="部署流程">部署流程</h2><p>本文不关注 Nginx、uWSGI、Django、Git等环境的安装，具体的安装步骤请到<ahref="#相关链接">相关链接</a>中查看。</p><h3 id="nginx-反向代理">Nginx 反向代理</h3><blockquote><p>关于 Nginx 的配置基础，可以参考<ahref="https://www.runoob.com/w3cnote/nginx-setup-intro.html">这个链接</a></p></blockquote><p>使用 Nginx 做反向代理，一般用到的配置参数是 proxy_pass。但是对于uWSGI，nginx 专门提供了一个更优的配置参数进行配置，即uwsgi_pass，配置文件核心内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Nginx配置文件部分内容<br># 处理动态请求<br>location /api &#123;<br>  include /etc/nginx/uwsgi_params; # Nginx提供的uWSGI配置<br>  uwsgi_pass 127.0.0.1:8000; # uWSGI监听的地址<br>&#125;<br><br># 处理静态请求<br>location / &#123;<br>  try_files $uri $uri/ /index.html;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编辑完配置文件后，需使用<code>nginx -s reload</code>命令重启nginx，配置文件才能生效。</p><h3 id="uwsgi-处理动态请求">uWSGI 处理动态请求</h3><p>uWSGI 可以手动启动，但是需要输入启动参数，这里让 uWSGI从配置文件启动。假设 Django 项目叫做 backend，uWSGI 的配置文件叫做uwsgi.ini，那么一个项目的结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Django项目结构<br>- backend<br>  - backend<br>    - __init__.py<br>    - settings.py<br>    - urls.py<br>    - asgi.py<br>    - wsgi.py<br>  - manage.py<br>  - uwsgi.ini<br></code></pre></div></td></tr></table></figure><p>配置文件 uwsgi.ini 的参考内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># uWSGI配置文件<br>[uwsgi]<br>socket=127.0.0.1:8000 # 使用nginx连接时使用<br>chdir=/path/to/backend # 项目目录<br>wsgi-file=backend/wsgi.py # 项目中wsgi.py文件的目录，相对于项目目录<br>processes=2 # 指定启动的工作进程数<br>threads=2 # 指定工作进程中的线程数<br>master=True # 指定在这些进程里有一个主进程<br>pidfile=uwsgi.pid # 保存启动之后主进程的pid<br>daemonize=uwsgi.log # 设置uwsgi后台运行，uwsgi.log保存日志信息<br>log-maxsize = 100000 # 设置日志文件最大字节数<br>max-requests = 1000 # 设置每个进程最大请求数<br></code></pre></div></td></tr></table></figure><p>在 uwsgi.ini 文件中输入配置后，就可以 cd到项目根目录下，使用<code>uwsgi --ini uwsgi.ini</code>的方式启动 uWSGI了。</p><h3 id="处理请求前缀">处理请求前缀</h3><p>若通过上述配置文件部署 Django，那么请求的前缀不会被自动去掉，即 Nginx虽然将<strong>https://ip:443/api/request</strong>这个请求传递给了Django，但是 Django 会将这个请求的 url 解析为 api/request 而不是request。</p><p>Nginx 官方推荐的解决方案是 Nginx 给 uWSGI 传递参数，uWSGI根据参数去除请求前缀，向配置文件中添加如下配置即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># Nginx配置文件部分内容<br>location /api &#123;<br>  ... # 表示其他配置，实际文件中不是省略号<br>  uwsgi_param SCRIPT_NAME /api; # 表示需要去掉api前缀<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"># uWSGI配置文件<br>... # 表示其他配置，实际文件中不是省略号<br>route-run = fixpathinfo: # 根据参数去除请求前缀<br></code></pre></div></td></tr></table></figure><h3 id="github-action-自动部署">Github Action 自动部署</h3><blockquote><p>若要实现向 Github 项目 push 之后就进行自动部署，可以考虑 GithubAction、Github Webhook 等方案，这里使用 Github Action。</p></blockquote><p>事实上，Django 项目的部署与更新非常简单，总体上来说需要做两件事：</p><ol type="1"><li>更新服务器上的 Python代码，考虑用<code>git pull</code>命令完成，这里需要注意服务器需要有操作项目仓库的权限</li><li>重启 uWSGI，使用<code>uwsgi --reload uwsgi.pid</code>即可</li></ol><p>注意，Nginx 是不需要重启的，因为 Nginx不需要做任何代码或者配置更新。</p><p>于是，可以这样编写<a href="https://docs.github.com/en/actions">GithubAction</a>的脚本：</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">main</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">setup</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">sudo</span> <span class="hljs-string">apt</span> <span class="hljs-string">install</span> <span class="hljs-string">sshpass</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pull</span> <span class="hljs-string">and</span> <span class="hljs-string">reload</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DST:</span> <span class="hljs-string">$&#123;&#123;secrets.DST_FOLDER&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">sshpass</span> <span class="hljs-string">-p</span> <span class="hljs-string">$&#123;&#123;secrets.PASSWORD&#125;&#125;</span> <span class="hljs-string">ssh</span> <span class="hljs-string">-o</span> <span class="hljs-string">StrictHostKeyChecking=no</span> <span class="hljs-string">$&#123;&#123;secrets.USER&#125;&#125;@$&#123;&#123;secrets.IP&#125;&#125;</span> <span class="hljs-string">&quot;cd $&#123;DST&#125;; git pull; uwsgi --reload uwsgi.pid&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="结语">结语</h2><p>至此，Nginx+uWSGI 部署 Django项目的大致流程就介绍完了。读者在自己的服务器上实践可能会遇到一些坑，建议在<ahref="https://www.google.com.hk/">Google</a>或者<ahref="https://stackoverflow.com/">StackOverflow</a>上查询相关答案，或者在下方留言区写下您遇到的问题。</p><h2 id="相关链接">相关链接</h2><ul><li>Github Actions 官方文档：https://docs.github.com/en/actions</li><li>uWSGI 官方文档：https://uwsgi-docs.readthedocs.io/en/latest/</li><li>Nginx 首页：https://www.nginx.com/</li><li>Django 首页：https://www.djangoproject.com/</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">本文记录了一种使用Nginx反向代理uWSGI，进行Django项目部署的方案，使用了Github Action实现了项目的自动部署。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Github探秘</title>
    <link href="https://blog.matrix53.top/2021/07/25/Github%E6%8E%A2%E7%A7%98/"/>
    <id>https://blog.matrix53.top/2021/07/25/Github%E6%8E%A2%E7%A7%98/</id>
    <published>2021-07-25T01:48:22.000Z</published>
    <updated>2022-05-07T16:23:08.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Github作为全世界最大的代码托管网站，无数顶尖极客云集于此，更有无数极为优秀的开源代码以供学习及应用。而Github 网页端功能及其提供的 API 非常强大，配套 Git直接就能实现完整的项目管理，下面本文将向读者介绍几个 Github的进阶功能，抛砖引玉。</p><h2 id="github-actions">Github Actions</h2><p>简单地说，Github Actions是一个脚本，能够在一个指定的时机，对于某个指定的 Github仓库做一些事情。</p><ul><li><strong>指定的时机</strong>可以是在某个人对该 Github 仓库 push之后，或者是该仓库新增了一个 issue之后，诸如此类时机都可以被指定为执行脚本的时机，详情见<ahref="https://docs.github.com/en/actions/reference/events-that-trigger-workflows">官方文档</a>。</li><li><strong>脚本</strong>可以非常的复杂，这里的脚本，是运行在 Github提供的临时容器里的，你可以指定容器的操作系统，可以在该容器里安装 Node.js等。</li></ul><p>容易想到可以将 Github Actions 用于自动部署，在成员向指定仓库 push之后，可以利用临时容器进行源代码的编译，并将要部署的文件传到自己的服务器上。从某种意义上来说，GithubActions 有点像钩子函数。</p><p>关于 Github Actions 入门及脚本编写，可以看这个<ahref="https://docs.github.com/en/actions">官方文档</a>。<imgsrc="/img/chore/github_action.png" alt="Github Actions" /></p><h2 id="github-apps">Github Apps</h2><p>Github Apps 和 Github Actions 比较类似，你可以在 Github顶栏的<strong>Marketplace</strong>里同时找到这两项 Github提供的功能。如果要说 Apps 和 Actions有什么不同的话，我认为体现在<strong>集成度</strong>上面，Apps的功能更为直接和完善，开箱即用。<img src="/img/chore/github_app.png"alt="Github Apps" /></p><p>Apps 就好像给编辑器安装的插件，而 Actions就好像给编辑器写的脚本。基于 GithubApps，你可以实现但不限于以下几件事：</p><ul><li>自动化项目构建、项目测试、项目部署等工作流</li><li>图片自动无损压缩，加快网络传输</li><li>自动关闭不活跃的 issue</li></ul><div class="note note-secondary">            <p>关于 Actions 和 Apps，读者可以在 Github 的<ahref="https://github.com/marketplace">Marketplace</a>上尽情探索。</p>          </div><h2 id="github-pages">Github Pages</h2><p>Github Pages 是一个用于网页展示的功能，于<strong>2008年</strong>推出，世界上的任何一个人，都能通过 Github展示自己的网页。可以利用 Github Pages进行个人博客托管、项目成果展示等，<ahref="https://blog.matrix53.top">我的个人博客</a>就是利用 Github Pages进行部署的，免去了购买服务器的费用。</p><p>具体来说，想要使用 Github Pages，必须建立一个名为 username.github.io的仓库（其中的 username 为用户名），然后在该仓库的设置中打开 Pages服务，这里就不赘述了。需要注意的是，不是只有该仓库才能启用 Github Pages服务，其他仓库也能启用 Pages 服务。</p><p>关于 Github Pages 的详细介绍和教程，请见<ahref="https://docs.github.com/en/pages">官方文档</a></p><h2 id="其他功能">其他功能</h2><p>Github 还有很多强大的功能，比如其提供的 REST API、GraphQLAPI、Projects 和 Gists 等。最后讲一个小故事吧，Github 在 2018 年 3 月 1日遭遇了有史以来最严重的 DDoS 攻击，峰值流量达 1.35Tbps，而 Github 在 10分钟之内化解了这次攻击。</p><h2 id="相关链接">相关链接</h2><ul><li>Github Actions 官方文档：https://docs.github.com/en/actions</li><li>Github Apps官方文档：https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps</li><li>Github Pages 官方文档：https://docs.github.com/en/pages</li><li>Github 功能总文档：https://docs.github.com/en</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">本文针对Github上的一些好用的功能进行介绍，包括但不限于Github Pages、Github Actions等功能，帮助读者了解Github的强大之处。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客配置历程</title>
    <link href="https://blog.matrix53.top/2021/07/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%8E%86%E7%A8%8B/"/>
    <id>https://blog.matrix53.top/2021/07/25/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E5%8E%86%E7%A8%8B/</id>
    <published>2021-07-25T01:11:04.000Z</published>
    <updated>2022-05-03T08:22:51.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一直有搭建个人博客的想法，早早就买好了域名和服务器。但奈何大二下学期课业压力实在太大，一直没有足够的空闲时间搭建博客，于是大二暑假先玩了一段时间，然后着手搭建个人博客。</p><h2 id="博客框架的选择">博客框架的选择</h2><p>目前比较火的博客框架有 WordPress、Jekyll、Hexo等，下面简单罗列一下这些框架的优势劣势：</p><ul><li><strong>WordPress</strong>：经典博客框架，插件和主题非常丰富，操作简单直白，但是需要购买云服务器进行部署，访问速度受限于云服务器带宽</li><li><strong>Jekyll</strong>：Github 原生支持的博客框架，只需要把项目源码push 到 Github 仓库里，Github就能自动生成博客页面，不需要购买服务器，但是渲染速度相对于 Hexo较慢</li><li><strong>Hexo</strong>：渲染速度比 Jekyll快，可以通过静态页面的形式直接部署到 GithubPages，不需要购买服务器，有中文文档</li></ul><p>最终，我选择了 Hexo 进行个人博客的搭建，将个人博客的静态文件部署到Github Pages，关于 Github Pages 及 Github的其他功能，详见我的另一篇文章<a href="/2021/07/25/Github%E6%8E%A2%E7%A7%98/" title="Github探秘">Github探秘</a>。<imgsrc="/img/chore/hexo_logo_index.png" alt="Hexo的logo" /></p><h2 id="博客主题的选择">博客主题的选择</h2><p>主题方面，我是直接在 Github 上找高 Star 的主题，最终选到了 Fluid这一款主题。事实上，我友链里的博客很多也用了这一款主题，看来大家的审美差不多（x</p><p>主题挑选有两个主要途径，一个是去 Github上以<strong>hexo-theme</strong>作为关键词进行搜索，另一个是去 Hexo 的<ahref="https://hexo.io/themes/">主题商城</a>进行挑选。</p><p>关于主题和博客框架的配置，各个主题的官网以及博客框架的官网都有很详细的教程，还可以在各大搜索引擎搜索，这里就不赘述了。</p><h2 id="评论方案的选择">评论方案的选择</h2><p>评论方面，由于 Hexo 博客是无后端的静态页面，所以需要借助外部 API来配置评论功能。大体来说外部 API 分为两种，一种是基于 Github 上的 issue进行评论的方案，另一种是基于各大 BaaS 供应商提供的服务。我选择的是基于Github issue 的 utterances 评论方案，该方案的特点是免费开源、使用 Github账号进行评论、文章和 Github issue 绑定、可直接访问评论者的 Github主页。</p><ul><li>基于 Github 上的 issue 的方案：<ahref="https://github.com/utterance/utterances">utterances</a>、<ahref="https://github.com/gitalk/gitalk">gitalk</a>等</li><li>基于 BaaS 供应商的方案：<ahref="https://valine.js.org/">valine</a>、<ahref="https://waline.js.org/">waline</a>、<ahref="https://disqus.com/">disqus</a>等</li></ul><p>另外，如果使用的是 Fluid 主题，那么 Fluid主题的官网和配置文件里有很详细的评论配置方案。</p><h2 id="公式渲染器的选择">公式渲染器的选择</h2><p>原生的 Hexo 框架不支持渲染 Latex，但是可以通过安装插件的方法支持Latex 语法。相关插件包括但不限于以下几个，我安装的插件是hexo-renderer-pandoc。</p><ul><li><ahref="https://github.com/hexojs/hexo-math">hexo-math</a>：同时支持 Katex和 Mathjax，是 Hexo 的官方数学公式插件</li><li><ahref="https://github.com/CHENXCHEN/hexo-renderer-markdown-it-plus">hexo-renderer-markdown-it-plus</a>：支持Katex，Fluid 主题推荐方案之一</li><li><ahref="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>：支持Mathjax，Fluid 主题推荐方案之一</li></ul><p>另外，Latex 是一套排版语言，而 Katex 和 Mathjax 是渲染 Latex的引擎。Katex 更为轻量，而 Mathjax 能渲染更复杂的数学符号，日常使用来说Katex 就够用了。</p><h2 id="相关链接">相关链接</h2><p>下面是我搭建博客时查阅的一些链接，以供读者参考：</p><ul><li>Hexo 框架官网：https://hexo.io</li><li>Fluid 主题官网：https://hexo.fluid-dev.com/docs</li><li>utterances评论方案仓库：https://github.com/utterance/utterances</li></ul><p>由于作者水平有限，所以文章中难免有少数不严谨之处，如有读者发现此类疏忽，恳请读者指出。另外，如果认为本文对您有帮助，欢迎请作者喝咖啡！<imgsrc="/img/global/wxQRcode_pay.png" alt="Matrix53的微信赞赏码" /></p>]]></content>
    
    
    <summary type="html">一直有搭建个人博客的想法，早早就买好了域名和服务器。但奈何大二下学期课业压力实在太大，一直没有足够的空闲时间搭建博客，于是大二暑假先玩了一段时间，然后着手搭建个人博客。</summary>
    
    
    
    <category term="随笔" scheme="https://blog.matrix53.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
